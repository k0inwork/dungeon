--- HIVE BLOCKS ---
BLOCK 0:

( --- HOST BINDINGS --- )
( Native WAForth Bindings )
( Usage: S" NAME" SCALL calls the bound JS function )

: JS_LOG   ( addr len -- ) S" JS_LOG" SCALL ;
: JS_EVENT ( code -- )     S" JS_EVENT" SCALL ;
: JS_ERR   ( code -- )     S" JS_ERR" SCALL ;
: JS_REGISTER_VSO ( addr typeId sizeBytes -- ) S" JS_REGISTER_VSO" SCALL ;
: JS_SYNC_OBJECT ( id typeId -- ptr ) S" JS_SYNC_OBJECT" SCALL ;
: JS_ASSERT ( actual expected -- ) S" JS_ASSERT" SCALL ;

BLOCK 1:

( --- CORE POLYFILLS --- )
( Essential words that might be missing in minimal Forth kernels )

( 1. 2DROP - Drop two items )
: 2DROP ( n1 n2 -- ) DROP DROP ;

( 2. NIP - Drop item below top )
: NIP ( n1 n2 -- n2 ) SWAP DROP ;

( 3. CELLS - Convert to byte offset )
: CELLS ( n -- n*4 ) 4 * ;

( 4. -ROT - Rotate stack backwards: n1 n2 n3 -- n3 n1 n2 )
: -ROT ( n1 n2 n3 -- n3 n1 n2 ) ROT ROT ;

( 4. CMOVE - Copy characters from src to dest )
( src dest u -- )
: CMOVE
  DUP 0= IF DROP 2DROP EXIT THEN ( Handle 0 length )
  0 DO
    OVER C@ OVER C!
    1+ SWAP 1+ SWAP
  LOOP
  2DROP
;

( 5. MATH HELPERS )
: MAX ( n1 n2 -- max ) 2DUP < IF SWAP THEN DROP ;
: MIN ( n1 n2 -- min ) 2DUP > IF SWAP THEN DROP ;
: NEGATE ( n -- -n ) 0 SWAP - ;
: ABS ( n -- |n| ) DUP 0 < IF NEGATE THEN ;

( 6. COMPARISONS )
: <= ( n1 n2 -- f ) > 0= ;
: >= ( n1 n2 -- f ) < 0= ;
: <> ( n1 n2 -- f ) = 0= ;

BLOCK 2:

( --- BITWISE MATH --- )
( Ensure standard bitwise words exist. WAForth usually has them, but explicit defs help portability )
: LSHIFT ( x u -- x' ) LSHIFT ;
: RSHIFT ( x u -- x' ) RSHIFT ;
: OR ( x1 x2 -- x3 ) OR ;
: AND ( x1 x2 -- x3 ) AND ;
: XOR ( x1 x2 -- x3 ) XOR ;

BLOCK 3:

( --- MEMORY MAP --- )
HEX
400   CONSTANT INPUT_QUEUE
10400 CONSTANT OUTPUT_QUEUE
70000 CONSTANT STR_BUF_START
7FFFF CONSTANT STR_BUF_END
D0000 CONSTANT TEMP_VSO_BUFFER
DECIMAL

( --- AUTO-GENERATED PROTOCOL CONSTANTS --- )
( --- KERNEL IDS --- )
0 CONSTANT K_HOST
1 CONSTANT K_GRID
2 CONSTANT K_PLAYER
3 CONSTANT K_HIVE
4 CONSTANT K_BATTLE
5 CONSTANT K_PLATFORM
255 CONSTANT K_BUS

( --- PROTOCOL OPCODES --- )
101 CONSTANT REQ_MOVE
102 CONSTANT REQ_TELEPORT
103 CONSTANT REQ_TERRAIN
105 CONSTANT REQ_PATH_STEP
201 CONSTANT EVT_MOVED
202 CONSTANT EVT_COLLIDE
203 CONSTANT EVT_SPAWN
204 CONSTANT EVT_DAMAGE
205 CONSTANT EVT_DEATH
206 CONSTANT EVT_ITEM_GET
207 CONSTANT EVT_LEVEL_TRANSITION
301 CONSTANT CMD_INTERACT
302 CONSTANT CMD_SPEAK
303 CONSTANT CMD_ATTACK
304 CONSTANT CMD_KILL
305 CONSTANT CMD_PICKUP
901 CONSTANT SYS_LOG
910 CONSTANT SYS_CHAN_SUB
911 CONSTANT SYS_CHAN_UNSUB
999 CONSTANT SYS_ERROR
1000 CONSTANT SYS_BLOB

( --- VSO TYPE IDS --- )
1 CONSTANT VSO_GRIDENTITY
2 CONSTANT VSO_HIVEENTITY
3 CONSTANT VSO_RPGENTITY
4 CONSTANT VSO_PLAYERSTATE


BLOCK 4:

VARIABLE M_OP
VARIABLE M_SENDER
VARIABLE M_TARGET
VARIABLE M_P1
VARIABLE M_P2
VARIABLE M_P3
VARIABLE LAST_PLAYER_X
VARIABLE LAST_PLAYER_Y

: UNPACK_MSG
  M_P3 !
  M_P2 !
  M_P1 !
  M_TARGET !
  M_SENDER !
  M_OP !
;

BLOCK 5:

( --- STRING PRIMITIVES --- )
VARIABLE STR_PTR
STR_BUF_START STR_PTR !

( Append string to circular buffer to ensure it persists for JS call )
( FIXED v1.12: Corrected CMOVE argument order )
: S+ ( addr len -- dest len )
  ( Check bounds: Reset to start if buffer full )
  DUP STR_PTR @ + STR_BUF_END > IF STR_BUF_START STR_PTR ! THEN

  STR_PTR @ >R       ( Save Dest to R-stack )

  ( src=addr dest=R@ u=len )
  OVER R@ 2 PICK CMOVE

  ( Update Pointer )
  DUP STR_PTR +!

  ( Return dest len )
  NIP R> SWAP
;

( Convert Number to String )
: N>S ( n -- addr len )
  DUP >R ABS 0 <# #S R> SIGN #> S+
;

BLOCK 6:

( --- STRING IO --- )

( Print String to JS Console - Requires JS_LOG bound )
: S. ( addr len -- )
  S+ JS_LOG
;

( Print Number to JS Console )
: .N ( n -- )
  N>S S.
;

( Dump Stack to Log )
: .S ( -- )
  DEPTH N>S S. S"  Items on stack" S.
;

BLOCK 7:

( --- BUS UTILITIES --- )
VARIABLE OUT_PTR
0 OUT_PTR !

( Write a 6-Cell Packet to Output Queue )
: BUS_SEND ( op sender target p1 p2 p3 -- )
  OUTPUT_QUEUE 4 + OUT_PTR @ CELLS + >R

  ( Stack: op sender target p1 p2 p3 )
  ( Use Return Stack to hold address )
  R@ 20 + ! ( p3 )
  R@ 16 + ! ( p2 )
  R@ 12 + ! ( p1 )
  R@ 8 + !  ( target )
  R@ 4 + !  ( sender )
  R@ !      ( op )
  R> DROP   ( Clean R stack )

  6 OUT_PTR +!
  OUT_PTR @ OUTPUT_QUEUE ! ( Update Count )
;

: BUS_READ_INPUT ( -- count )
  INPUT_QUEUE @
;

: GET_MSG_ADDR ( index -- addr )
  INPUT_QUEUE 4 + SWAP CELLS +
;

( --- PERSISTENCE HELPERS --- )
( Store HERE at fixed location 0x3F0 for JS readout )
: SYNC_HERE HERE 1008 ! ;

( --- BLOB EXTENSION v2.0 --- )
( Send Variable Length Data )
( Stack: data_addr data_len sender target real_op -- )
: BUS_SEND_BLOB
  OUTPUT_QUEUE 4 + OUT_PTR @ CELLS + >R

  ( 1. Write Header: SYS_BLOB sender target len real_op 0 )
  0               R@ 20 + ! ( p3: unused )
  DUP             R@ 16 + ! ( p2: real_op )
  3 PICK          R@ 12 + ! ( p1: len )
  3 PICK          R@ 8 + !  ( target )
  4 PICK          R@ 4 + !  ( sender )
  SYS_BLOB        R@ !      ( op: SYS_BLOB )

  ( 2. Write Payload )
  ( Addr of payload start in queue = R@ + 24 )
  R@ 24 +      ( dest_addr )
  5 ROLL       ( dest_addr data_addr )
  5 ROLL       ( dest_addr data_addr len )

  ( Copy Memory: cells to bytes )
  DUP >R       ( Save len for ptr update )
  CELLS CMOVE

  R> DROP      ( Clean len )
  R> DROP      ( Clean R-Stack header addr )

  ( 3. Update Pointer: 6 + Len )
  SWAP DROP ( Clean real_op )
  6 + OUT_PTR +!
  OUT_PTR @ OUTPUT_QUEUE !
;

BLOCK 8:
 DECIMAL
( --- STRUCT OFFSETS --- )
( Struct: GridEntity )
20 CONSTANT SIZEOF_GRIDENTITY
0 CONSTANT OFF_GRIDENTITY_CHAR
4 CONSTANT OFF_GRIDENTITY_COLOR
8 CONSTANT OFF_GRIDENTITY_Y
12 CONSTANT OFF_GRIDENTITY_X
16 CONSTANT OFF_GRIDENTITY_TYPE
( Struct: HiveEntity )
12 CONSTANT SIZEOF_HIVEENTITY
0 CONSTANT OFF_HIVEENTITY_X
0 CONSTANT OFF_X
4 CONSTANT OFF_HIVEENTITY_Y
4 CONSTANT OFF_Y
8 CONSTANT OFF_HIVEENTITY_TYPE
8 CONSTANT OFF_TYPE
( Struct: RpgEntity )
36 CONSTANT SIZEOF_RPGENTITY
0 CONSTANT OFF_RPGENTITY_HP
0 CONSTANT OFF_HP
4 CONSTANT OFF_RPGENTITY_MAXHP
4 CONSTANT OFF_MAXHP
8 CONSTANT OFF_RPGENTITY_ATK
8 CONSTANT OFF_ATK
12 CONSTANT OFF_RPGENTITY_DEF
12 CONSTANT OFF_DEF
16 CONSTANT OFF_RPGENTITY_LEVEL
16 CONSTANT OFF_LEVEL
20 CONSTANT OFF_RPGENTITY_EXP
20 CONSTANT OFF_EXP
24 CONSTANT OFF_RPGENTITY_STATE
24 CONSTANT OFF_STATE
28 CONSTANT OFF_RPGENTITY_TARGETID
28 CONSTANT OFF_TARGETID
32 CONSTANT OFF_RPGENTITY_INVITEM
32 CONSTANT OFF_INVITEM
( Struct: PlayerState )
56 CONSTANT SIZEOF_PLAYERSTATE
0 CONSTANT OFF_PLAYERSTATE_HP
4 CONSTANT OFF_PLAYERSTATE_MAXHP
8 CONSTANT OFF_PLAYERSTATE_GOLD
12 CONSTANT OFF_PLAYERSTATE_INVCOUNT
16 CONSTANT OFF_PLAYERSTATE_INV0
20 CONSTANT OFF_PLAYERSTATE_INV1
24 CONSTANT OFF_PLAYERSTATE_INV2
28 CONSTANT OFF_PLAYERSTATE_INV3
32 CONSTANT OFF_PLAYERSTATE_INV4
36 CONSTANT OFF_PLAYERSTATE_INV5
40 CONSTANT OFF_PLAYERSTATE_INV6
44 CONSTANT OFF_PLAYERSTATE_INV7
48 CONSTANT OFF_PLAYERSTATE_INV8
52 CONSTANT OFF_PLAYERSTATE_INV9
( --------------------- )
( --- AETHER AUTO-GLOBALS --- )
VARIABLE CHANNELS_INITED
0 CHANNELS_INITED !
0 CONSTANT K_HOST
1 CONSTANT K_GRID
2 CONSTANT K_PLAYER
3 CONSTANT K_HIVE
4 CONSTANT K_BATTLE
5 CONSTANT K_PLATFORM
255 CONSTANT K_BUS
101 CONSTANT REQ_MOVE
102 CONSTANT REQ_TELEPORT
103 CONSTANT REQ_TERRAIN
105 CONSTANT REQ_PATH_STEP
201 CONSTANT EVT_MOVED
202 CONSTANT EVT_COLLIDE
203 CONSTANT EVT_SPAWN
204 CONSTANT EVT_DAMAGE
205 CONSTANT EVT_DEATH
206 CONSTANT EVT_ITEM_GET
207 CONSTANT EVT_LEVEL_TRANSITION
301 CONSTANT CMD_INTERACT
302 CONSTANT CMD_SPEAK
303 CONSTANT CMD_ATTACK
304 CONSTANT CMD_KILL
305 CONSTANT CMD_PICKUP
901 CONSTANT SYS_LOG
910 CONSTANT SYS_CHAN_SUB
911 CONSTANT SYS_CHAN_UNSUB
999 CONSTANT SYS_ERROR
1000 CONSTANT SYS_BLOB
1 CONSTANT VSO_GRIDENTITY
2 CONSTANT VSO_HIVEENTITY
3 CONSTANT VSO_RPGENTITY
4 CONSTANT VSO_PLAYERSTATE
1024 CONSTANT INPUT_QUEUE
66560 CONSTANT OUTPUT_QUEUE
458752 CONSTANT STR_BUF_START
524287 CONSTANT STR_BUF_END
851968 CONSTANT TEMP_VSO_BUFFER
1028 CONSTANT INBOX
66564 CONSTANT OUTBOX
1024 CONSTANT IN_COUNT
66560 CONSTANT OUT_COUNT
32 CONSTANT MAX_ENTITIES
VARIABLE HIVE_ENT_COUNT
VARIABLE RNG_SEED
589824 CONSTANT HIVE_ENTITIES
HIVE_ENTITIES 2 12 JS_REGISTER_VSO
VARIABLE LV_BUS_SEND_OP
VARIABLE LV_BUS_SEND_SENDER
VARIABLE LV_BUS_SEND_TARGET
VARIABLE LV_BUS_SEND_P1
VARIABLE LV_BUS_SEND_P2
VARIABLE LV_BUS_SEND_P3
VARIABLE LV_GET_HIVE_PTR_ID
VARIABLE LV_UPDATE_HIVE_ENTITY_ID
VARIABLE LV_UPDATE_HIVE_ENTITY_X
VARIABLE LV_UPDATE_HIVE_ENTITY_Y
VARIABLE LV_UPDATE_HIVE_ENTITY_ENT
VARIABLE LV_UPDATE_HIVE_ENTITY_NEXT
VARIABLE LV_SET_HIVE_TYPE_ID
VARIABLE LV_SET_HIVE_TYPE_TYPE
VARIABLE LV_SET_HIVE_TYPE_ENT
VARIABLE LV_ON_NPC_SYNC_OPCODE
VARIABLE LV_ON_NPC_SYNC_SENDER
VARIABLE LV_ON_NPC_SYNC_ARG1
VARIABLE LV_ON_NPC_SYNC_ARG2
VARIABLE LV_ON_NPC_SYNC_ARG3
VARIABLE LV_RAND_DIR_X_R
VARIABLE LV_RAND_DIR_X_M
VARIABLE LV_RAND_DIR_Y_R
VARIABLE LV_RAND_DIR_Y_M
VARIABLE LV_ABS_N
VARIABLE LV_DECIDE_ACTION_ID
VARIABLE LV_DECIDE_ACTION_ENT
VARIABLE LV_DECIDE_ACTION_STATS
VARIABLE LV_DECIDE_ACTION_PLAYERSTATS
VARIABLE LV_DECIDE_ACTION_DX
VARIABLE LV_DECIDE_ACTION_DY
VARIABLE LV_DECIDE_ACTION_DIST
VARIABLE LV_DECIDE_ACTION_RDX
VARIABLE LV_DECIDE_ACTION_RDY
VARIABLE LV_DECIDE_ACTION_R
VARIABLE LV_DECIDE_ACTION_M
VARIABLE LV_ON_BUS_EVENT_OP
VARIABLE LV_ON_BUS_EVENT_SENDER
VARIABLE LV_ON_BUS_EVENT_P1
VARIABLE LV_ON_BUS_EVENT_P2
VARIABLE LV_ON_BUS_EVENT_P3
VARIABLE LV_PROCESS_INBOX_TOTALCOUNT
VARIABLE LV_PROCESS_INBOX_OFFSET
VARIABLE LV_PROCESS_INBOX_OP
VARIABLE LV_RUN_CYCLE_I
VARIABLE LV_RUN_CYCLE_COUNT
VARIABLE LV_INIT_HIVE_I
VARIABLE LV_INIT_HIVE_ENT
( ------------------------- )
  0
  M_OP !
  0
  M_SENDER !
  0
  M_TARGET !
  0
  M_P1 !
  0
  M_P2 !
  0
  M_P3 !
  0
  OUT_PTR !

: BUS_SEND
  LV_BUS_SEND_P3 !
  LV_BUS_SEND_P2 !
  LV_BUS_SEND_P1 !
  LV_BUS_SEND_TARGET !
  LV_BUS_SEND_SENDER !
  LV_BUS_SEND_OP !
  S" [BUS] Sending packet..."
  S.
  LV_BUS_SEND_OP @
  OUTBOX
  OUT_PTR @
  CELLS + !
  LV_BUS_SEND_SENDER @
  OUTBOX
  OUT_PTR @
  1
  +
  CELLS + !
  LV_BUS_SEND_TARGET @
  OUTBOX
  OUT_PTR @
  2
  +
  CELLS + !
  LV_BUS_SEND_P1 @
  OUTBOX
  OUT_PTR @
  3
  +
  CELLS + !
  LV_BUS_SEND_P2 @
  OUTBOX
  OUT_PTR @
  4
  +
  CELLS + !
  LV_BUS_SEND_P3 @
  OUTBOX
  OUT_PTR @
  5
  +
  CELLS + !
  6
  OUT_PTR +!
  OUT_PTR @
  OUT_COUNT
  0
  CELLS + !
;

: BUS_READ_INPUT
  IN_COUNT
  0
  CELLS + @
  EXIT
;
  0
  HIVE_ENT_COUNT !
  12345
  RNG_SEED !
  0
  LAST_PLAYER_X !
  0
  LAST_PLAYER_Y !

: RANDOM
  RNG_SEED @
  1103515245
  *
  12345
  +
  RNG_SEED !
  RNG_SEED @
  16
  RSHIFT
  32767
  AND
  EXIT
;

: GET_HIVE_PTR
  LV_GET_HIVE_PTR_ID !
  LV_GET_HIVE_PTR_ID @
  HIVE_ENTITIES SWAP SIZEOF_HIVEENTITY * +
  EXIT
;

: UPDATE_HIVE_ENTITY
  LV_UPDATE_HIVE_ENTITY_Y !
  LV_UPDATE_HIVE_ENTITY_X !
  LV_UPDATE_HIVE_ENTITY_ID !
  LV_UPDATE_HIVE_ENTITY_ID @
  GET_HIVE_PTR
  LV_UPDATE_HIVE_ENTITY_ENT !
  LV_UPDATE_HIVE_ENTITY_X @
  LV_UPDATE_HIVE_ENTITY_ENT @
  OFF_HIVEENTITY_X + !
  LV_UPDATE_HIVE_ENTITY_Y @
  LV_UPDATE_HIVE_ENTITY_ENT @
  OFF_HIVEENTITY_Y + !
  LV_UPDATE_HIVE_ENTITY_ID @
  1
  +
  LV_UPDATE_HIVE_ENTITY_NEXT !
  LV_UPDATE_HIVE_ENTITY_NEXT @
  HIVE_ENT_COUNT @
  >
  IF
  LV_UPDATE_HIVE_ENTITY_NEXT @
  HIVE_ENT_COUNT !
  THEN
;

: SET_HIVE_TYPE
  LV_SET_HIVE_TYPE_TYPE !
  LV_SET_HIVE_TYPE_ID !
  LV_SET_HIVE_TYPE_ID @
  GET_HIVE_PTR
  LV_SET_HIVE_TYPE_ENT !
  LV_SET_HIVE_TYPE_TYPE @
  LV_SET_HIVE_TYPE_ENT @
  OFF_HIVEENTITY_TYPE + !
;

: ON_NPC_SYNC
  LV_ON_NPC_SYNC_ARG3 !
  LV_ON_NPC_SYNC_ARG2 !
  LV_ON_NPC_SYNC_ARG1 !
  LV_ON_NPC_SYNC_SENDER !
  LV_ON_NPC_SYNC_OPCODE !
  LV_ON_NPC_SYNC_OPCODE @
  EVT_MOVED
  =
  IF
  LV_ON_NPC_SYNC_ARG1 @
  LV_ON_NPC_SYNC_ARG2 @
  LV_ON_NPC_SYNC_ARG3 @
  UPDATE_HIVE_ENTITY
  LV_ON_NPC_SYNC_ARG1 @
  0
  =
  IF
  LV_ON_NPC_SYNC_ARG2 @
  LAST_PLAYER_X !
  LV_ON_NPC_SYNC_ARG3 @
  LAST_PLAYER_Y !
  THEN
  THEN
  LV_ON_NPC_SYNC_OPCODE @
  EVT_SPAWN
  =
  IF
  LV_ON_NPC_SYNC_ARG1 @
  LV_ON_NPC_SYNC_ARG2 @
  SET_HIVE_TYPE
  LV_ON_NPC_SYNC_ARG2 @
  2
  =
  IF
  S" [HIVE] Aggressive Entity Registered"
  S.
  THEN
  THEN
  LV_ON_NPC_SYNC_OPCODE @
  EVT_DEATH
  =
  IF
  LV_ON_NPC_SYNC_ARG1 @
  3
  SET_HIVE_TYPE
  THEN
;

: RAND_DIR_X
  RANDOM
  LV_RAND_DIR_X_R !
  LV_RAND_DIR_X_R @
  4
  MOD
  LV_RAND_DIR_X_M !
  LV_RAND_DIR_X_M @
  1
  =
  IF
  1
  EXIT
  THEN
  LV_RAND_DIR_X_M @
  2
  =
  IF
  1
  NEGATE
  EXIT
  THEN
  0
  EXIT
;

: RAND_DIR_Y
  RANDOM
  LV_RAND_DIR_Y_R !
  LV_RAND_DIR_Y_R @
  4
  MOD
  LV_RAND_DIR_Y_M !
  LV_RAND_DIR_Y_M @
  0
  =
  IF
  1
  NEGATE
  EXIT
  THEN
  LV_RAND_DIR_Y_M @
  3
  =
  IF
  1
  EXIT
  THEN
  0
  EXIT
;

: ABS
  LV_ABS_N !
  LV_ABS_N @
  0
  <
  IF
  0
  LV_ABS_N @
  -
  EXIT
  THEN
  LV_ABS_N @
  EXIT
;

: DECIDE_ACTION
  LV_DECIDE_ACTION_ID !
  LV_DECIDE_ACTION_ID @
  GET_HIVE_PTR
  LV_DECIDE_ACTION_ENT !
  LV_DECIDE_ACTION_ENT @
  OFF_HIVEENTITY_TYPE + @
  3
  =
  IF
  EXIT
  THEN
  LV_DECIDE_ACTION_ID @
  LV_DECIDE_ACTION_ID @
  VSO_RPGENTITY JS_SYNC_OBJECT
  LV_DECIDE_ACTION_STATS !
  LV_DECIDE_ACTION_STATS @
  OFF_RPGENTITY_STATE + @
  1
  =
  IF
  EXIT
  THEN
  LV_DECIDE_ACTION_ENT @
  OFF_HIVEENTITY_TYPE + @
  2
  =
  IF
  0
  0
  VSO_RPGENTITY JS_SYNC_OBJECT
  LV_DECIDE_ACTION_PLAYERSTATS !
  LV_DECIDE_ACTION_PLAYERSTATS @
  OFF_RPGENTITY_HP + @
  20
  <
  IF
  S" Target weak! Pressing attack!"
  S.
  THEN
  LV_DECIDE_ACTION_ENT @
  OFF_HIVEENTITY_X + @
  LAST_PLAYER_X @
  -
  ABS
  LV_DECIDE_ACTION_DX !
  LV_DECIDE_ACTION_ENT @
  OFF_HIVEENTITY_Y + @
  LAST_PLAYER_Y @
  -
  ABS
  LV_DECIDE_ACTION_DY !
  LV_DECIDE_ACTION_DX @
  LV_DECIDE_ACTION_DY @
  +
  LV_DECIDE_ACTION_DIST !
  LV_DECIDE_ACTION_DIST @
  10
  <
  IF
  REQ_PATH_STEP
  3 ( Sender )
  K_GRID
  LV_DECIDE_ACTION_ID @
  LAST_PLAYER_X @
  LAST_PLAYER_Y @
  BUS_SEND
  ELSE
  RAND_DIR_X
  LV_DECIDE_ACTION_RDX !
  RAND_DIR_Y
  LV_DECIDE_ACTION_RDY !
  REQ_MOVE
  3 ( Sender )
  K_GRID
  LV_DECIDE_ACTION_ID @
  LV_DECIDE_ACTION_RDX @
  LV_DECIDE_ACTION_RDY @
  BUS_SEND
  THEN
  ELSE
  RANDOM
  LV_DECIDE_ACTION_R !
  LV_DECIDE_ACTION_R @
  100
  MOD
  LV_DECIDE_ACTION_M !
  LV_DECIDE_ACTION_M @
  50
  <
  IF
  RAND_DIR_X
  LV_DECIDE_ACTION_RDX !
  RAND_DIR_Y
  LV_DECIDE_ACTION_RDY !
  REQ_MOVE
  3 ( Sender )
  K_GRID
  LV_DECIDE_ACTION_ID @
  LV_DECIDE_ACTION_RDX @
  LV_DECIDE_ACTION_RDY @
  BUS_SEND
  THEN
  THEN
;

: ON_BUS_EVENT
  LV_ON_BUS_EVENT_P3 !
  LV_ON_BUS_EVENT_P2 !
  LV_ON_BUS_EVENT_P1 !
  LV_ON_BUS_EVENT_SENDER !
  LV_ON_BUS_EVENT_OP !
  LV_ON_BUS_EVENT_OP @
  EVT_COLLIDE
  =
  IF
  LV_ON_BUS_EVENT_P3 @
  1
  =
  IF
  LV_ON_BUS_EVENT_P1 @
  0
  >
  IF
  LV_ON_BUS_EVENT_P2 @
  0
  =
  IF
  S" Enemy Attacks Player!"
  S.
  CMD_ATTACK
  3 ( Sender )
  K_BUS
  LV_ON_BUS_EVENT_P1 @
  LV_ON_BUS_EVENT_P2 @
  0
  BUS_SEND
  THEN
  THEN
  THEN
  THEN
;

: HANDLE_EVENTS
( --- [AJS-CHANNELS] EVENT DISPATCHERS --- )
  M_TARGET @ 59718 = IF
  M_OP @ M_SENDER @ M_P1 @ M_P2 @ M_P3 @ ON_NPC_SYNC
  THEN
  M_TARGET @ 3 = IF
  M_OP @ M_SENDER @ M_P1 @ M_P2 @ M_P3 @ ON_BUS_EVENT
  THEN
  M_TARGET @ 255 = IF
  M_OP @ M_SENDER @ M_P1 @ M_P2 @ M_P3 @ ON_BUS_EVENT
  THEN
;

: PROCESS_INBOX
  0
  OUT_PTR !
  BUS_READ_INPUT
  LV_PROCESS_INBOX_TOTALCOUNT !
  0
  LV_PROCESS_INBOX_OFFSET !
  BEGIN
  LV_PROCESS_INBOX_OFFSET @
  LV_PROCESS_INBOX_TOTALCOUNT @
  <
  WHILE
  INBOX
  LV_PROCESS_INBOX_OFFSET @
  CELLS + @
  LV_PROCESS_INBOX_OP !
  LV_PROCESS_INBOX_OP @
  SYS_BLOB
  =
  IF
  INBOX
  LV_PROCESS_INBOX_OFFSET @
  4
  +
  CELLS + @
  M_OP !
  INBOX
  LV_PROCESS_INBOX_OFFSET @
  1
  +
  CELLS + @
  M_SENDER !
  INBOX
  LV_PROCESS_INBOX_OFFSET @
  2
  +
  CELLS + @
  M_TARGET !
  INBOX
  LV_PROCESS_INBOX_OFFSET @
  3
  +
  CELLS + @
  M_P1 !
  INPUT_QUEUE
  4
  +
  LV_PROCESS_INBOX_OFFSET @
  6
  +
  4
  *
  +
  M_P2 !
  HANDLE_EVENTS
  M_P1 @
  6
  +
  LV_PROCESS_INBOX_OFFSET +!
  ELSE
  LV_PROCESS_INBOX_OP @
  M_OP !
  INBOX
  LV_PROCESS_INBOX_OFFSET @
  1
  +
  CELLS + @
  M_SENDER !
  INBOX
  LV_PROCESS_INBOX_OFFSET @
  2
  +
  CELLS + @
  M_TARGET !
  INBOX
  LV_PROCESS_INBOX_OFFSET @
  3
  +
  CELLS + @
  M_P1 !
  INBOX
  LV_PROCESS_INBOX_OFFSET @
  4
  +
  CELLS + @
  M_P2 !
  INBOX
  LV_PROCESS_INBOX_OFFSET @
  5
  +
  CELLS + @
  M_P3 !
  HANDLE_EVENTS
  6
  LV_PROCESS_INBOX_OFFSET +!
  THEN
  REPEAT
  0
  IN_COUNT
  0
  CELLS + !
;

: RUN_CYCLE
  1
  LV_RUN_CYCLE_I !
  HIVE_ENT_COUNT @
  LV_RUN_CYCLE_COUNT !
  BEGIN
  LV_RUN_CYCLE_I @
  LV_RUN_CYCLE_COUNT @
  <
  WHILE
  LV_RUN_CYCLE_I @
  DECIDE_ACTION
  1 LV_RUN_CYCLE_I +!
  REPEAT
;

: RUN_HIVE_CYCLE
  PROCESS_INBOX
  RUN_CYCLE
;

: INIT_HIVE
  0
  LV_INIT_HIVE_I !
  BEGIN
  LV_INIT_HIVE_I @
  MAX_ENTITIES
  <
  WHILE
  LV_INIT_HIVE_I @
  GET_HIVE_PTR
  LV_INIT_HIVE_ENT !
  0
  LV_INIT_HIVE_ENT @
  OFF_HIVEENTITY_X + !
  0
  LV_INIT_HIVE_ENT @
  OFF_HIVEENTITY_Y + !
  0
  LV_INIT_HIVE_ENT @
  OFF_HIVEENTITY_TYPE + !
  1 LV_INIT_HIVE_I +!
  REPEAT
  0
  HIVE_ENT_COUNT !
  S" [HIVE] Memory Reset"
  S.
  ( Subscribed to Channel: npc_sync )
  ( Subscribed to Channel: Self )
  ( Subscribed to Channel: BUS )
;

: AJS_INIT_CHANNELS
  SYS_CHAN_SUB 3 K_HOST 59718 0 0 BUS_SEND
  SYS_CHAN_SUB 3 K_HOST 3 0 0 BUS_SEND
  SYS_CHAN_SUB 3 K_HOST 255 0 0 BUS_SEND
;
AJS_INIT_CHANNELS
BLOCK 9:
 : INIT_HIVE INIT_HIVE AJS_INIT_CHANNELS ;
BLOCK 10:
 : RUN_HIVE_CYCLE RUN_HIVE_CYCLE ;
--- BATTLE BLOCKS ---
BLOCK 0:

( --- HOST BINDINGS --- )
( Native WAForth Bindings )
( Usage: S" NAME" SCALL calls the bound JS function )

: JS_LOG   ( addr len -- ) S" JS_LOG" SCALL ;
: JS_EVENT ( code -- )     S" JS_EVENT" SCALL ;
: JS_ERR   ( code -- )     S" JS_ERR" SCALL ;
: JS_REGISTER_VSO ( addr typeId sizeBytes -- ) S" JS_REGISTER_VSO" SCALL ;
: JS_SYNC_OBJECT ( id typeId -- ptr ) S" JS_SYNC_OBJECT" SCALL ;
: JS_ASSERT ( actual expected -- ) S" JS_ASSERT" SCALL ;

BLOCK 1:

( --- CORE POLYFILLS --- )
( Essential words that might be missing in minimal Forth kernels )

( 1. 2DROP - Drop two items )
: 2DROP ( n1 n2 -- ) DROP DROP ;

( 2. NIP - Drop item below top )
: NIP ( n1 n2 -- n2 ) SWAP DROP ;

( 3. CELLS - Convert to byte offset )
: CELLS ( n -- n*4 ) 4 * ;

( 4. -ROT - Rotate stack backwards: n1 n2 n3 -- n3 n1 n2 )
: -ROT ( n1 n2 n3 -- n3 n1 n2 ) ROT ROT ;

( 4. CMOVE - Copy characters from src to dest )
( src dest u -- )
: CMOVE
  DUP 0= IF DROP 2DROP EXIT THEN ( Handle 0 length )
  0 DO
    OVER C@ OVER C!
    1+ SWAP 1+ SWAP
  LOOP
  2DROP
;

( 5. MATH HELPERS )
: MAX ( n1 n2 -- max ) 2DUP < IF SWAP THEN DROP ;
: MIN ( n1 n2 -- min ) 2DUP > IF SWAP THEN DROP ;
: NEGATE ( n -- -n ) 0 SWAP - ;
: ABS ( n -- |n| ) DUP 0 < IF NEGATE THEN ;

( 6. COMPARISONS )
: <= ( n1 n2 -- f ) > 0= ;
: >= ( n1 n2 -- f ) < 0= ;
: <> ( n1 n2 -- f ) = 0= ;

BLOCK 2:

( --- BITWISE MATH --- )
( Ensure standard bitwise words exist. WAForth usually has them, but explicit defs help portability )
: LSHIFT ( x u -- x' ) LSHIFT ;
: RSHIFT ( x u -- x' ) RSHIFT ;
: OR ( x1 x2 -- x3 ) OR ;
: AND ( x1 x2 -- x3 ) AND ;
: XOR ( x1 x2 -- x3 ) XOR ;

BLOCK 3:

( --- MEMORY MAP --- )
HEX
400   CONSTANT INPUT_QUEUE
10400 CONSTANT OUTPUT_QUEUE
70000 CONSTANT STR_BUF_START
7FFFF CONSTANT STR_BUF_END
D0000 CONSTANT TEMP_VSO_BUFFER
DECIMAL

( --- AUTO-GENERATED PROTOCOL CONSTANTS --- )
( --- KERNEL IDS --- )
0 CONSTANT K_HOST
1 CONSTANT K_GRID
2 CONSTANT K_PLAYER
3 CONSTANT K_HIVE
4 CONSTANT K_BATTLE
5 CONSTANT K_PLATFORM
255 CONSTANT K_BUS

( --- PROTOCOL OPCODES --- )
101 CONSTANT REQ_MOVE
102 CONSTANT REQ_TELEPORT
103 CONSTANT REQ_TERRAIN
105 CONSTANT REQ_PATH_STEP
201 CONSTANT EVT_MOVED
202 CONSTANT EVT_COLLIDE
203 CONSTANT EVT_SPAWN
204 CONSTANT EVT_DAMAGE
205 CONSTANT EVT_DEATH
206 CONSTANT EVT_ITEM_GET
207 CONSTANT EVT_LEVEL_TRANSITION
301 CONSTANT CMD_INTERACT
302 CONSTANT CMD_SPEAK
303 CONSTANT CMD_ATTACK
304 CONSTANT CMD_KILL
305 CONSTANT CMD_PICKUP
901 CONSTANT SYS_LOG
910 CONSTANT SYS_CHAN_SUB
911 CONSTANT SYS_CHAN_UNSUB
999 CONSTANT SYS_ERROR
1000 CONSTANT SYS_BLOB

( --- VSO TYPE IDS --- )
1 CONSTANT VSO_GRIDENTITY
2 CONSTANT VSO_HIVEENTITY
3 CONSTANT VSO_RPGENTITY
4 CONSTANT VSO_PLAYERSTATE


BLOCK 4:

VARIABLE M_OP
VARIABLE M_SENDER
VARIABLE M_TARGET
VARIABLE M_P1
VARIABLE M_P2
VARIABLE M_P3
VARIABLE LAST_PLAYER_X
VARIABLE LAST_PLAYER_Y

: UNPACK_MSG
  M_P3 !
  M_P2 !
  M_P1 !
  M_TARGET !
  M_SENDER !
  M_OP !
;

BLOCK 5:

( --- STRING PRIMITIVES --- )
VARIABLE STR_PTR
STR_BUF_START STR_PTR !

( Append string to circular buffer to ensure it persists for JS call )
( FIXED v1.12: Corrected CMOVE argument order )
: S+ ( addr len -- dest len )
  ( Check bounds: Reset to start if buffer full )
  DUP STR_PTR @ + STR_BUF_END > IF STR_BUF_START STR_PTR ! THEN

  STR_PTR @ >R       ( Save Dest to R-stack )

  ( src=addr dest=R@ u=len )
  OVER R@ 2 PICK CMOVE

  ( Update Pointer )
  DUP STR_PTR +!

  ( Return dest len )
  NIP R> SWAP
;

( Convert Number to String )
: N>S ( n -- addr len )
  DUP >R ABS 0 <# #S R> SIGN #> S+
;

BLOCK 6:

( --- STRING IO --- )

( Print String to JS Console - Requires JS_LOG bound )
: S. ( addr len -- )
  S+ JS_LOG
;

( Print Number to JS Console )
: .N ( n -- )
  N>S S.
;

( Dump Stack to Log )
: .S ( -- )
  DEPTH N>S S. S"  Items on stack" S.
;

BLOCK 7:

( --- BUS UTILITIES --- )
VARIABLE OUT_PTR
0 OUT_PTR !

( Write a 6-Cell Packet to Output Queue )
: BUS_SEND ( op sender target p1 p2 p3 -- )
  OUTPUT_QUEUE 4 + OUT_PTR @ CELLS + >R

  ( Stack: op sender target p1 p2 p3 )
  ( Use Return Stack to hold address )
  R@ 20 + ! ( p3 )
  R@ 16 + ! ( p2 )
  R@ 12 + ! ( p1 )
  R@ 8 + !  ( target )
  R@ 4 + !  ( sender )
  R@ !      ( op )
  R> DROP   ( Clean R stack )

  6 OUT_PTR +!
  OUT_PTR @ OUTPUT_QUEUE ! ( Update Count )
;

: BUS_READ_INPUT ( -- count )
  INPUT_QUEUE @
;

: GET_MSG_ADDR ( index -- addr )
  INPUT_QUEUE 4 + SWAP CELLS +
;

( --- PERSISTENCE HELPERS --- )
( Store HERE at fixed location 0x3F0 for JS readout )
: SYNC_HERE HERE 1008 ! ;

( --- BLOB EXTENSION v2.0 --- )
( Send Variable Length Data )
( Stack: data_addr data_len sender target real_op -- )
: BUS_SEND_BLOB
  OUTPUT_QUEUE 4 + OUT_PTR @ CELLS + >R

  ( 1. Write Header: SYS_BLOB sender target len real_op 0 )
  0               R@ 20 + ! ( p3: unused )
  DUP             R@ 16 + ! ( p2: real_op )
  3 PICK          R@ 12 + ! ( p1: len )
  3 PICK          R@ 8 + !  ( target )
  4 PICK          R@ 4 + !  ( sender )
  SYS_BLOB        R@ !      ( op: SYS_BLOB )

  ( 2. Write Payload )
  ( Addr of payload start in queue = R@ + 24 )
  R@ 24 +      ( dest_addr )
  5 ROLL       ( dest_addr data_addr )
  5 ROLL       ( dest_addr data_addr len )

  ( Copy Memory: cells to bytes )
  DUP >R       ( Save len for ptr update )
  CELLS CMOVE

  R> DROP      ( Clean len )
  R> DROP      ( Clean R-Stack header addr )

  ( 3. Update Pointer: 6 + Len )
  SWAP DROP ( Clean real_op )
  6 + OUT_PTR +!
  OUT_PTR @ OUTPUT_QUEUE !
;

BLOCK 8:
 DECIMAL
( --- STRUCT OFFSETS --- )
( Struct: GridEntity )
20 CONSTANT SIZEOF_GRIDENTITY
0 CONSTANT OFF_GRIDENTITY_CHAR
4 CONSTANT OFF_GRIDENTITY_COLOR
8 CONSTANT OFF_GRIDENTITY_Y
12 CONSTANT OFF_GRIDENTITY_X
16 CONSTANT OFF_GRIDENTITY_TYPE
( Struct: HiveEntity )
12 CONSTANT SIZEOF_HIVEENTITY
0 CONSTANT OFF_HIVEENTITY_X
4 CONSTANT OFF_HIVEENTITY_Y
8 CONSTANT OFF_HIVEENTITY_TYPE
( Struct: RpgEntity )
36 CONSTANT SIZEOF_RPGENTITY
0 CONSTANT OFF_RPGENTITY_HP
0 CONSTANT OFF_HP
4 CONSTANT OFF_RPGENTITY_MAXHP
4 CONSTANT OFF_MAXHP
8 CONSTANT OFF_RPGENTITY_ATK
8 CONSTANT OFF_ATK
12 CONSTANT OFF_RPGENTITY_DEF
12 CONSTANT OFF_DEF
16 CONSTANT OFF_RPGENTITY_LEVEL
16 CONSTANT OFF_LEVEL
20 CONSTANT OFF_RPGENTITY_EXP
20 CONSTANT OFF_EXP
24 CONSTANT OFF_RPGENTITY_STATE
24 CONSTANT OFF_STATE
28 CONSTANT OFF_RPGENTITY_TARGETID
28 CONSTANT OFF_TARGETID
32 CONSTANT OFF_RPGENTITY_INVITEM
32 CONSTANT OFF_INVITEM
( Struct: PlayerState )
56 CONSTANT SIZEOF_PLAYERSTATE
0 CONSTANT OFF_PLAYERSTATE_HP
4 CONSTANT OFF_PLAYERSTATE_MAXHP
8 CONSTANT OFF_PLAYERSTATE_GOLD
12 CONSTANT OFF_PLAYERSTATE_INVCOUNT
16 CONSTANT OFF_PLAYERSTATE_INV0
20 CONSTANT OFF_PLAYERSTATE_INV1
24 CONSTANT OFF_PLAYERSTATE_INV2
28 CONSTANT OFF_PLAYERSTATE_INV3
32 CONSTANT OFF_PLAYERSTATE_INV4
36 CONSTANT OFF_PLAYERSTATE_INV5
40 CONSTANT OFF_PLAYERSTATE_INV6
44 CONSTANT OFF_PLAYERSTATE_INV7
48 CONSTANT OFF_PLAYERSTATE_INV8
52 CONSTANT OFF_PLAYERSTATE_INV9
( --------------------- )
( --- AETHER AUTO-GLOBALS --- )
VARIABLE CHANNELS_INITED
0 CHANNELS_INITED !
0 CONSTANT K_HOST
1 CONSTANT K_GRID
2 CONSTANT K_PLAYER
3 CONSTANT K_HIVE
4 CONSTANT K_BATTLE
5 CONSTANT K_PLATFORM
255 CONSTANT K_BUS
101 CONSTANT REQ_MOVE
102 CONSTANT REQ_TELEPORT
103 CONSTANT REQ_TERRAIN
105 CONSTANT REQ_PATH_STEP
201 CONSTANT EVT_MOVED
202 CONSTANT EVT_COLLIDE
203 CONSTANT EVT_SPAWN
204 CONSTANT EVT_DAMAGE
205 CONSTANT EVT_DEATH
206 CONSTANT EVT_ITEM_GET
207 CONSTANT EVT_LEVEL_TRANSITION
301 CONSTANT CMD_INTERACT
302 CONSTANT CMD_SPEAK
303 CONSTANT CMD_ATTACK
304 CONSTANT CMD_KILL
305 CONSTANT CMD_PICKUP
901 CONSTANT SYS_LOG
910 CONSTANT SYS_CHAN_SUB
911 CONSTANT SYS_CHAN_UNSUB
999 CONSTANT SYS_ERROR
1000 CONSTANT SYS_BLOB
1 CONSTANT VSO_GRIDENTITY
2 CONSTANT VSO_HIVEENTITY
3 CONSTANT VSO_RPGENTITY
4 CONSTANT VSO_PLAYERSTATE
1024 CONSTANT INPUT_QUEUE
66560 CONSTANT OUTPUT_QUEUE
458752 CONSTANT STR_BUF_START
524287 CONSTANT STR_BUF_END
851968 CONSTANT TEMP_VSO_BUFFER
1028 CONSTANT INBOX
66564 CONSTANT OUTBOX
1024 CONSTANT IN_COUNT
66560 CONSTANT OUT_COUNT
32 CONSTANT MAX_ENTITIES
36 CONSTANT RPG_SIZE
VARIABLE ENTITY_COUNT
655360 CONSTANT RPG_TABLE
RPG_TABLE 3 36 JS_REGISTER_VSO
VARIABLE LV_BUS_SEND_OP
VARIABLE LV_BUS_SEND_SENDER
VARIABLE LV_BUS_SEND_TARGET
VARIABLE LV_BUS_SEND_P1
VARIABLE LV_BUS_SEND_P2
VARIABLE LV_BUS_SEND_P3
VARIABLE LV_GET_RPG_PTR_ID
VARIABLE LV_INIT_STATS_ID
VARIABLE LV_INIT_STATS_TYPE
VARIABLE LV_INIT_STATS_E
VARIABLE LV_INIT_STATS_P
VARIABLE LV_LOG_COMBAT_SRCID
VARIABLE LV_LOG_COMBAT_TGTID
VARIABLE LV_LOG_COMBAT_DMG
VARIABLE LV_SKILL_BASIC_ATTACK_SRCID
VARIABLE LV_SKILL_BASIC_ATTACK_TGTID
VARIABLE LV_SKILL_BASIC_ATTACK_SRC
VARIABLE LV_SKILL_BASIC_ATTACK_TGT
VARIABLE LV_SKILL_BASIC_ATTACK_DMG
VARIABLE LV_SKILL_HEAVY_SMASH_SRCID
VARIABLE LV_SKILL_HEAVY_SMASH_TGTID
VARIABLE LV_SKILL_HEAVY_SMASH_SRC
VARIABLE LV_SKILL_HEAVY_SMASH_TGT
VARIABLE LV_SKILL_HEAVY_SMASH_DMG
VARIABLE LV_SKILL_HEAL_SELF_SRCID
VARIABLE LV_SKILL_HEAL_SELF_SRC
VARIABLE LV_SKILL_HEAL_SELF_AMOUNT
VARIABLE LV_SKILL_FIREBALL_SRCID
VARIABLE LV_SKILL_FIREBALL_TGTID
VARIABLE LV_SKILL_FIREBALL_SRC
VARIABLE LV_SKILL_FIREBALL_TGT
VARIABLE LV_SKILL_FIREBALL_DMG
VARIABLE LV_EXECUTE_SKILL_SRCID
VARIABLE LV_EXECUTE_SKILL_TGTID
VARIABLE LV_EXECUTE_SKILL_SKILLID
VARIABLE LV_EXECUTE_SKILL_REMAININGHP
VARIABLE LV_EXECUTE_SKILL_SRC
VARIABLE LV_EXECUTE_SKILL_TGT
VARIABLE LV_ON_NPC_SYNC_OPCODE
VARIABLE LV_ON_NPC_SYNC_SENDER
VARIABLE LV_ON_NPC_SYNC_P1
VARIABLE LV_ON_NPC_SYNC_P2
VARIABLE LV_ON_NPC_SYNC_P3
VARIABLE LV_ON_NPC_SYNC_E
VARIABLE LV_ON_BATTLE_REQUEST_OP
VARIABLE LV_ON_BATTLE_REQUEST_SENDER
VARIABLE LV_ON_BATTLE_REQUEST_P1
VARIABLE LV_ON_BATTLE_REQUEST_P2
VARIABLE LV_ON_BATTLE_REQUEST_P3
VARIABLE LV_INIT_BATTLE_I
VARIABLE LV_INIT_BATTLE_E
VARIABLE LV_PROCESS_INBOX_TOTALCOUNT
VARIABLE LV_PROCESS_INBOX_OFFSET
VARIABLE LV_PROCESS_INBOX_OP
( ------------------------- )
  0
  M_OP !
  0
  M_SENDER !
  0
  M_TARGET !
  0
  M_P1 !
  0
  M_P2 !
  0
  M_P3 !
  0
  OUT_PTR !

: BUS_SEND
  LV_BUS_SEND_P3 !
  LV_BUS_SEND_P2 !
  LV_BUS_SEND_P1 !
  LV_BUS_SEND_TARGET !
  LV_BUS_SEND_SENDER !
  LV_BUS_SEND_OP !
  S" [BUS] Sending packet..."
  S.
  LV_BUS_SEND_OP @
  OUTBOX
  OUT_PTR @
  CELLS + !
  LV_BUS_SEND_SENDER @
  OUTBOX
  OUT_PTR @
  1
  +
  CELLS + !
  LV_BUS_SEND_TARGET @
  OUTBOX
  OUT_PTR @
  2
  +
  CELLS + !
  LV_BUS_SEND_P1 @
  OUTBOX
  OUT_PTR @
  3
  +
  CELLS + !
  LV_BUS_SEND_P2 @
  OUTBOX
  OUT_PTR @
  4
  +
  CELLS + !
  LV_BUS_SEND_P3 @
  OUTBOX
  OUT_PTR @
  5
  +
  CELLS + !
  6
  OUT_PTR +!
  OUT_PTR @
  OUT_COUNT
  0
  CELLS + !
;

: BUS_READ_INPUT
  IN_COUNT
  0
  CELLS + @
  EXIT
;
  0
  ENTITY_COUNT !

: GET_RPG_PTR
  LV_GET_RPG_PTR_ID !
  LV_GET_RPG_PTR_ID @
  RPG_TABLE SWAP SIZEOF_RPGENTITY * +
  EXIT
;

: INIT_STATS
  LV_INIT_STATS_TYPE !
  LV_INIT_STATS_ID !
  LV_INIT_STATS_ID @
  GET_RPG_PTR
  LV_INIT_STATS_E !
  100
  LV_INIT_STATS_E @
  OFF_RPGENTITY_MAXHP + !
  100
  LV_INIT_STATS_E @
  OFF_RPGENTITY_HP + !
  10
  LV_INIT_STATS_E @
  OFF_RPGENTITY_ATK + !
  2
  LV_INIT_STATS_E @
  OFF_RPGENTITY_DEF + !
  1
  LV_INIT_STATS_E @
  OFF_RPGENTITY_LEVEL + !
  0
  LV_INIT_STATS_E @
  OFF_RPGENTITY_STATE + !
  0
  LV_INIT_STATS_E @
  OFF_RPGENTITY_INVITEM + !
  LV_INIT_STATS_ID @
  0
  =
  IF
  0
  0
  VSO_PLAYERSTATE JS_SYNC_OBJECT
  LV_INIT_STATS_P !
  LV_INIT_STATS_P @
  OFF_PLAYERSTATE_MAXHP + @
  0
  >
  IF
  LV_INIT_STATS_P @
  OFF_PLAYERSTATE_MAXHP + @
  LV_INIT_STATS_E @
  OFF_RPGENTITY_MAXHP + !
  LV_INIT_STATS_P @
  OFF_PLAYERSTATE_HP + @
  LV_INIT_STATS_E @
  OFF_RPGENTITY_HP + !
  ELSE
  200
  LV_INIT_STATS_E @
  OFF_RPGENTITY_MAXHP + !
  200
  LV_INIT_STATS_E @
  OFF_RPGENTITY_HP + !
  THEN
  20
  LV_INIT_STATS_E @
  OFF_RPGENTITY_ATK + !
  THEN
  S" Stats Init for ID:"
  S.
  LV_INIT_STATS_ID @
  .N
;

: LOG_COMBAT
  LV_LOG_COMBAT_DMG !
  LV_LOG_COMBAT_TGTID !
  LV_LOG_COMBAT_SRCID !
  LV_LOG_COMBAT_SRCID @
  0
  =
  IF
  S" You deal damage:"
  S.
  LV_LOG_COMBAT_DMG @
  .N
  ELSE
  S" Enemy hits YOU for "
  S.
  LV_LOG_COMBAT_DMG @
  .N
  S"  dmg"
  S.
  THEN
  EVT_DAMAGE
  4 ( Sender )
  32367 ( Channel: combat_events )
  LV_LOG_COMBAT_SRCID @
  LV_LOG_COMBAT_TGTID @
  LV_LOG_COMBAT_DMG @
  BUS_SEND
;

: SKILL_BASIC_ATTACK
  LV_SKILL_BASIC_ATTACK_TGTID !
  LV_SKILL_BASIC_ATTACK_SRCID !
  LV_SKILL_BASIC_ATTACK_SRCID @
  GET_RPG_PTR
  LV_SKILL_BASIC_ATTACK_SRC !
  LV_SKILL_BASIC_ATTACK_TGTID @
  GET_RPG_PTR
  LV_SKILL_BASIC_ATTACK_TGT !
  LV_SKILL_BASIC_ATTACK_SRC @
  OFF_RPGENTITY_ATK + @
  LV_SKILL_BASIC_ATTACK_TGT @
  OFF_RPGENTITY_DEF + @
  -
  LV_SKILL_BASIC_ATTACK_DMG !
  LV_SKILL_BASIC_ATTACK_DMG @
  1
  <
  IF
  1
  LV_SKILL_BASIC_ATTACK_DMG !
  THEN
  LV_SKILL_BASIC_ATTACK_DMG @
  NEGATE
  LV_SKILL_BASIC_ATTACK_TGT @
  OFF_RPGENTITY_HP + +!
  LV_SKILL_BASIC_ATTACK_SRCID @
  LV_SKILL_BASIC_ATTACK_TGTID @
  LV_SKILL_BASIC_ATTACK_DMG @
  LOG_COMBAT
  EVT_DAMAGE
  4 ( Sender )
  K_BUS
  LV_SKILL_BASIC_ATTACK_TGTID @
  LV_SKILL_BASIC_ATTACK_DMG @
  0
  BUS_SEND
  LV_SKILL_BASIC_ATTACK_TGT @
  OFF_RPGENTITY_HP + @
  EXIT
;

: SKILL_HEAVY_SMASH
  LV_SKILL_HEAVY_SMASH_TGTID !
  LV_SKILL_HEAVY_SMASH_SRCID !
  LV_SKILL_HEAVY_SMASH_SRCID @
  GET_RPG_PTR
  LV_SKILL_HEAVY_SMASH_SRC !
  LV_SKILL_HEAVY_SMASH_TGTID @
  GET_RPG_PTR
  LV_SKILL_HEAVY_SMASH_TGT !
  LV_SKILL_HEAVY_SMASH_SRC @
  OFF_RPGENTITY_ATK + @
  2
  *
  LV_SKILL_HEAVY_SMASH_DMG !
  LV_SKILL_HEAVY_SMASH_DMG @
  NEGATE
  LV_SKILL_HEAVY_SMASH_TGT @
  OFF_RPGENTITY_HP + +!
  LV_SKILL_HEAVY_SMASH_SRCID @
  LV_SKILL_HEAVY_SMASH_TGTID @
  LV_SKILL_HEAVY_SMASH_DMG @
  LOG_COMBAT
  EVT_DAMAGE
  4 ( Sender )
  K_BUS
  LV_SKILL_HEAVY_SMASH_TGTID @
  LV_SKILL_HEAVY_SMASH_DMG @
  2
  BUS_SEND
  LV_SKILL_HEAVY_SMASH_TGT @
  OFF_RPGENTITY_HP + @
  EXIT
;

: SKILL_HEAL_SELF
  LV_SKILL_HEAL_SELF_SRCID !
  LV_SKILL_HEAL_SELF_SRCID @
  GET_RPG_PTR
  LV_SKILL_HEAL_SELF_SRC !
  20
  LV_SKILL_HEAL_SELF_AMOUNT !
  LV_SKILL_HEAL_SELF_AMOUNT @
  LV_SKILL_HEAL_SELF_SRC @
  OFF_RPGENTITY_HP + +!
  LV_SKILL_HEAL_SELF_SRC @
  OFF_RPGENTITY_HP + @
  LV_SKILL_HEAL_SELF_SRC @
  OFF_RPGENTITY_MAXHP + @
  >
  IF
  LV_SKILL_HEAL_SELF_SRC @
  OFF_RPGENTITY_MAXHP + @
  LV_SKILL_HEAL_SELF_SRC @
  OFF_RPGENTITY_HP + !
  THEN
  S" You HEAL for "
  S.
  LV_SKILL_HEAL_SELF_AMOUNT @
  .N
  S"  HP"
  S.
  EVT_DAMAGE
  4 ( Sender )
  K_BUS
  LV_SKILL_HEAL_SELF_SRCID @
  LV_SKILL_HEAL_SELF_AMOUNT @
  NEGATE
  4
  BUS_SEND
;

: SKILL_FIREBALL
  LV_SKILL_FIREBALL_TGTID !
  LV_SKILL_FIREBALL_SRCID !
  LV_SKILL_FIREBALL_SRCID @
  GET_RPG_PTR
  LV_SKILL_FIREBALL_SRC !
  LV_SKILL_FIREBALL_TGTID @
  GET_RPG_PTR
  LV_SKILL_FIREBALL_TGT !
  40
  LV_SKILL_FIREBALL_DMG !
  LV_SKILL_FIREBALL_DMG @
  NEGATE
  LV_SKILL_FIREBALL_TGT @
  OFF_RPGENTITY_HP + +!
  LV_SKILL_FIREBALL_SRCID @
  LV_SKILL_FIREBALL_TGTID @
  LV_SKILL_FIREBALL_DMG @
  LOG_COMBAT
  EVT_DAMAGE
  4 ( Sender )
  K_BUS
  LV_SKILL_FIREBALL_TGTID @
  LV_SKILL_FIREBALL_DMG @
  1
  BUS_SEND
  LV_SKILL_FIREBALL_TGT @
  OFF_RPGENTITY_HP + @
  EXIT
;

: EXECUTE_SKILL
  LV_EXECUTE_SKILL_SKILLID !
  LV_EXECUTE_SKILL_TGTID !
  LV_EXECUTE_SKILL_SRCID !
  100
  LV_EXECUTE_SKILL_REMAININGHP !
  LV_EXECUTE_SKILL_SRCID @
  GET_RPG_PTR
  LV_EXECUTE_SKILL_SRC !
  LV_EXECUTE_SKILL_SRC @
  OFF_RPGENTITY_STATE + @
  1
  =
  IF
  EXIT
  THEN
  LV_EXECUTE_SKILL_TGTID @
  GET_RPG_PTR
  LV_EXECUTE_SKILL_TGT !
  LV_EXECUTE_SKILL_TGT @
  OFF_RPGENTITY_STATE + @
  1
  =
  IF
  S" Target already dead."
  S.
  EXIT
  THEN
  LV_EXECUTE_SKILL_SKILLID @
  0
  =
  IF
  LV_EXECUTE_SKILL_SRCID @
  LV_EXECUTE_SKILL_TGTID @
  SKILL_BASIC_ATTACK
  LV_EXECUTE_SKILL_REMAININGHP !
  THEN
  LV_EXECUTE_SKILL_SKILLID @
  1
  =
  IF
  LV_EXECUTE_SKILL_SRCID @
  LV_EXECUTE_SKILL_TGTID @
  SKILL_HEAVY_SMASH
  LV_EXECUTE_SKILL_REMAININGHP !
  THEN
  LV_EXECUTE_SKILL_SKILLID @
  2
  =
  IF
  LV_EXECUTE_SKILL_SRCID @
  SKILL_HEAL_SELF
  THEN
  LV_EXECUTE_SKILL_SKILLID @
  3
  =
  IF
  LV_EXECUTE_SKILL_SRCID @
  LV_EXECUTE_SKILL_TGTID @
  SKILL_FIREBALL
  LV_EXECUTE_SKILL_REMAININGHP !
  THEN
  LV_EXECUTE_SKILL_REMAININGHP @
  0
  <=
  IF
  LV_EXECUTE_SKILL_TGT @
  OFF_RPGENTITY_STATE + @
  0
  =
  IF
  1
  LV_EXECUTE_SKILL_TGT @
  OFF_RPGENTITY_STATE + !
  EVT_DEATH
  4 ( Sender )
  K_BUS
  LV_EXECUTE_SKILL_TGTID @
  LV_EXECUTE_SKILL_TGT @
  OFF_RPGENTITY_INVITEM + @
  0
  BUS_SEND
  S" Entity Died:"
  S.
  LV_EXECUTE_SKILL_TGTID @
  .N
  LV_EXECUTE_SKILL_TGTID @
  0
  =
  IF
  S" GAME OVER"
  S.
  THEN
  THEN
  THEN
;

: ON_NPC_SYNC
  LV_ON_NPC_SYNC_P3 !
  LV_ON_NPC_SYNC_P2 !
  LV_ON_NPC_SYNC_P1 !
  LV_ON_NPC_SYNC_SENDER !
  LV_ON_NPC_SYNC_OPCODE !
  LV_ON_NPC_SYNC_OPCODE @
  EVT_SPAWN
  =
  IF
  LV_ON_NPC_SYNC_P1 @
  LV_ON_NPC_SYNC_P2 @
  INIT_STATS
  LV_ON_NPC_SYNC_P1 @
  GET_RPG_PTR
  LV_ON_NPC_SYNC_E !
  LV_ON_NPC_SYNC_P2 @
  2
  =
  IF
  2001
  LV_ON_NPC_SYNC_E @
  OFF_RPGENTITY_INVITEM + !
  ELSE
  LV_ON_NPC_SYNC_P2 @
  1
  =
  IF
  2003
  LV_ON_NPC_SYNC_E @
  OFF_RPGENTITY_INVITEM + !
  THEN
  THEN
  THEN
;

: ON_BATTLE_REQUEST
  LV_ON_BATTLE_REQUEST_P3 !
  LV_ON_BATTLE_REQUEST_P2 !
  LV_ON_BATTLE_REQUEST_P1 !
  LV_ON_BATTLE_REQUEST_SENDER !
  LV_ON_BATTLE_REQUEST_OP !
  LV_ON_BATTLE_REQUEST_OP @
  CMD_ATTACK
  =
  IF
  LV_ON_BATTLE_REQUEST_P1 @
  LV_ON_BATTLE_REQUEST_P2 @
  LV_ON_BATTLE_REQUEST_P3 @
  EXECUTE_SKILL
  THEN
;

: INIT_BATTLE
  0
  LV_INIT_BATTLE_I !
  BEGIN
  LV_INIT_BATTLE_I @
  MAX_ENTITIES
  <
  WHILE
  LV_INIT_BATTLE_I @
  GET_RPG_PTR
  LV_INIT_BATTLE_E !
  0
  LV_INIT_BATTLE_E @
  OFF_RPGENTITY_HP + !
  0
  LV_INIT_BATTLE_E @
  OFF_RPGENTITY_MAXHP + !
  0
  LV_INIT_BATTLE_E @
  OFF_RPGENTITY_ATK + !
  0
  LV_INIT_BATTLE_E @
  OFF_RPGENTITY_DEF + !
  0
  LV_INIT_BATTLE_E @
  OFF_RPGENTITY_LEVEL + !
  0
  LV_INIT_BATTLE_E @
  OFF_RPGENTITY_EXP + !
  0
  LV_INIT_BATTLE_E @
  OFF_RPGENTITY_STATE + !
  0
  LV_INIT_BATTLE_E @
  OFF_RPGENTITY_TARGETID + !
  0
  LV_INIT_BATTLE_E @
  OFF_RPGENTITY_INVITEM + !
  1 LV_INIT_BATTLE_I +!
  REPEAT
  0
  ENTITY_COUNT !
  S" [BATTLE] Battle Kernel Initialized"
  S.
  ( Subscribed to Channel: npc_sync )
  ( Subscribed to Channel: Self )
  ( Subscribed to Channel: BUS )
;

: HANDLE_EVENTS
( --- [AJS-CHANNELS] EVENT DISPATCHERS --- )
  M_TARGET @ 59718 = IF
  M_OP @ M_SENDER @ M_P1 @ M_P2 @ M_P3 @ ON_NPC_SYNC
  THEN
  M_TARGET @ 4 = IF
  M_OP @ M_SENDER @ M_P1 @ M_P2 @ M_P3 @ ON_BATTLE_REQUEST
  THEN
  M_TARGET @ 255 = IF
  M_OP @ M_SENDER @ M_P1 @ M_P2 @ M_P3 @ ON_BATTLE_REQUEST
  THEN
;

: PROCESS_INBOX
  0
  OUT_PTR !
  BUS_READ_INPUT
  LV_PROCESS_INBOX_TOTALCOUNT !
  0
  LV_PROCESS_INBOX_OFFSET !
  BEGIN
  LV_PROCESS_INBOX_OFFSET @
  LV_PROCESS_INBOX_TOTALCOUNT @
  <
  WHILE
  INBOX
  LV_PROCESS_INBOX_OFFSET @
  CELLS + @
  LV_PROCESS_INBOX_OP !
  LV_PROCESS_INBOX_OP @
  SYS_BLOB
  =
  IF
  INBOX
  LV_PROCESS_INBOX_OFFSET @
  4
  +
  CELLS + @
  M_OP !
  INBOX
  LV_PROCESS_INBOX_OFFSET @
  1
  +
  CELLS + @
  M_SENDER !
  INBOX
  LV_PROCESS_INBOX_OFFSET @
  2
  +
  CELLS + @
  M_TARGET !
  INBOX
  LV_PROCESS_INBOX_OFFSET @
  3
  +
  CELLS + @
  M_P1 !
  INPUT_QUEUE
  4
  +
  LV_PROCESS_INBOX_OFFSET @
  6
  +
  4
  *
  +
  M_P2 !
  HANDLE_EVENTS
  M_P1 @
  6
  +
  LV_PROCESS_INBOX_OFFSET +!
  ELSE
  LV_PROCESS_INBOX_OP @
  M_OP !
  INBOX
  LV_PROCESS_INBOX_OFFSET @
  1
  +
  CELLS + @
  M_SENDER !
  INBOX
  LV_PROCESS_INBOX_OFFSET @
  2
  +
  CELLS + @
  M_TARGET !
  INBOX
  LV_PROCESS_INBOX_OFFSET @
  3
  +
  CELLS + @
  M_P1 !
  INBOX
  LV_PROCESS_INBOX_OFFSET @
  4
  +
  CELLS + @
  M_P2 !
  INBOX
  LV_PROCESS_INBOX_OFFSET @
  5
  +
  CELLS + @
  M_P3 !
  HANDLE_EVENTS
  6
  LV_PROCESS_INBOX_OFFSET +!
  THEN
  REPEAT
  0
  IN_COUNT
  0
  CELLS + !
;

: RUN_BATTLE_CYCLE
  PROCESS_INBOX
;

: AJS_INIT_CHANNELS
  SYS_CHAN_SUB 4 K_HOST 59718 0 0 BUS_SEND
  SYS_CHAN_SUB 4 K_HOST 4 0 0 BUS_SEND
  SYS_CHAN_SUB 4 K_HOST 255 0 0 BUS_SEND
;
AJS_INIT_CHANNELS
BLOCK 9:
 : INIT_BATTLE INIT_BATTLE AJS_INIT_CHANNELS ;
